《大话设计模式》读书笔记（14）

																老板回来，我不知道----观察者模式
																
																
																
																
	1. 观察者模式：又称为发布-订阅(Pubilsh/Subscribe)模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象(ConcreteObserver)同时监听某一个主题对象(ConcreteSubject)，这个主题对象在状态发生变化的时候，会通知所有观察者对象，使它们能够自动更新自己。简单来说就是，当主题Subject的状态发生了改变，所有的观察者Observer都会收到通知。观察者模式属于行为型模式。
		* Subject类：主题或抽象通知者，一般用一个抽象类或者一个接口实现，他把所有的对观察者对象的引用保存在一个集合里，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象；
		* Observer类：抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。这个接口叫做更新接口。
		* ConcreteSubject类：是具体主题或具体通知者，当主题内部的状态变化时，会给保存的观察者通知
		* ConcreteObserver类：是具体的观察者，实现抽象观察者角色所要求的更新接口，该更新接口用于主题(通知者)对观察者进行状态信息的通知；
	2. 观察者模式的效果就是：解除耦合，让耦合双方都依赖于抽象，而不依赖于具体，从而使得各自的变化都不会直接影响到另一边的变化。
	3. 观察者模式的使用场景：当一个对象的改变需要同时改变其他对象，而且他不知道具体有多少对象有待改变时，可以考虑使用观察者模式。  
	4. 观察者模式的不足：如果通知者和观察者互相不知道对方的存在，状态变化通知时需要调用的方法也就不确定了，或者说状态变化时通知需要调用的方法不同名，就无法使用观察者模式了。
	5. 使用事件委托机制解决观察者模式的不足(前提是的.NET中)：
		* 委托：就是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以向其他任何方法一行，具有参数和返回值。委托可以看作是对函数的抽象，是函数的“类”，委托的实例将代表一个具体的函数；
		* 委托就像是C++中的函数指针模板；或者说委托是一个特殊的类，委托的函数就是这个类中委托的实例，
		* 一个委托可以搭载多个方法，所有方法被一次唤醒，它可以使得委托对象所搭载的方法不属于同一个类。
		* 委托的前提：委托对象所搭载的所有方法必须具有相同的原型和形式，也就是拥有相同的参数列表和返回值类型。


