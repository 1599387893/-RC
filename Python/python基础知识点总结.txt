1.python与C/C++的异同：
	*python是一种解释型语言，会比编译型语言慢很多
	*python是面向对象型的语言

2.Python三元表达式：
	格式：条件为真时 if 条件 else 条件为假时

3.python函数调用没有显式返回值时，函数返回None

4.列表，元组和字典的区别
	列表(List)：[]
		列表中的数据项可以进行修改或者更新；
		多个列表可以进行+ * in for 
		可以将元组转换成列表
		二维数组[ [0 for i in range(cols)] for i in range(rows)]
		中文乱码： str(Chinese).decode('string_secape')
		
	元组(tuple)：()
		和列表相似，不同之处在于元组中的数据项不可以修改
		元组虽然不可以修改，但是可以进行连接组合 + * in for 
		当元组中只有一个数据项时，需要在该数据项之后加上一个逗号，将元组和数学公式中的小括号区分开来
		元组切片更新之后就不是原来的元组了，而是一个新的元组
		
	字典(dict)：{}
		一种可变容器模型
		字典中的每个键值对都使用：分割， 不同键值对之间使用逗号分割
		字典中的键值是唯一的，如果重复，将只保留最后一个
		字典中的键值必须是不可变的，可以是数字，字符串，元组，或者是布尔类型的
		访问字典中的键值时，最好使用get()来替换[]访问

5.string tuple numbers都是不可更改的对象，而list dict是可以修改的对象。

6.变量是没有类型的，它仅仅是一个对象的引用（一个指针）

7.函数调用时的参数类型：
	必备参数：函数调用时的参数个数和顺序必须一致
	关键字参数：函数调用时参数的顺序可以与声明不一致
	默认参数：
	不定长参数：在参数名前加上*(元组) ，即可接收多个参数，也可以使用**，来表示字典

8.匿名函数：
	python使用lambda来创建匿名函数。lambda的主体是一个表达式
	格式： 函数名 = lambda 逻辑控制

9.全局变量想要作用于函数内，需要使用global

10.import导入包的作用就是将导入包中的符号表引入到执行这个声明的模块的全局符号表中。
	import ...  和 from ... import ...的区别
		import... 在调用函数时必须带上包名，而 from ... import ...则不需要

11.python包，简单来说就是一个文件夹，但在该文件夹下必须存在__init__,py文件，该文件可以为空，__init__.py作用就是标识当前文件夹是一个包。

12.闭包：(闭包就是引用了自由变量的函数)
	简单来说就是一个函数定义中引用了函数外定义的变量，并且该函数可以在其定义环境外被执行。这样的一个函数称为闭包。
	闭包中的自由变量：
		闭包中的引用的自由变量只和具体的闭包有关联，闭包的每个实例引用的自由变量互不干扰。
		一个闭包实例对其自由变量的修改会被传递到下一次该闭包实例的调用。
	闭包主要用途就是：用于装饰器的实现。
	闭包相比于普通函数会多出一个__closure__()的属性，里面定义了一个元组用于存放所有的cell对象，每个cell对象一一保存了这个闭包中所有的外部变量。
		(cell对象是实现多个作用于引用的变量)
	建议：返回闭包中不要引用任何循环变量或者后续会发生变化的变量。
	闭包的格式
	'''
	def 外层函数(参数):
    def 内层函数():
        print("内层函数执行", 参数)

    return 内层函数

	内层函数的引用 = 外层函数("传入参数")
	内层函数的引用()
	'''
	闭包的理解：
		****  一般在函数结束后，就会释放临时变量，但是在闭包中，由于内函数使用了外函数的临时变量，此时外函数会把临时变量
		    和内函数绑定在一起，这样虽然外函数结束了，但调用内函数时依旧能够使用临时变量，即“闭包外层的参数可以在内存中进行保存。”
	如果需要在内函数中改变外函数的值，需要使用nonlocal关键字来声明变量；

13.	yield关键字：(断点)
	yield将一个函数修饰成一个生成器函数，即生成器函数的内部含有yield表达式。
	调用生成器函数(含有yield表达式的函数)时，会返回一个特殊的迭代器，叫做生成器。（生成器是可迭代对象）
	生成器函数被调用后并不会立即执行，而是返回一个用于迭代的生成器，当该生成器调用成员方法时，该生成器函数中的代码才会执行。
	生成器函数运行时，运行到yield关键字修饰的部分之后，停止运行，知道下次调用时才会从上次停止的地方(即yield之后)开始运行。
	yield常用于需要返回一组数据，并且含有循环的函数中。
	yield的好处：
		可以降低内存占用，提高运行速度
	yield一般配合next() send()函数使用，这两个函数可以让生成器向下走一步，send()函数能传入一个值作为yield表达式整体的结果使用
	
14. python三大器： 装饰器，迭代器，生成器	
		生成器(generator):
			定义：python中，一边循环一边计算的机制，称为生成器。
			作用：降低内存的消耗。
			创建：将一个列表生成式的[]改成()即可 / 在一个函数中使用yield关键字
			生成器可以循环的原因：生成器对象有一个next()方法，生成器函数则是调用next(g)来循环
		装饰器(Decorator):
			“装饰器函数(wrapper)的外部函数(xxx)传入将要装饰的函数名(func)，返回经过修饰后函数的名字；内层函数(闭包)负责修饰被修饰函数”
			定义：为已经存在的函数或对象添加额外的功能。本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能。
			返回值：装饰器的返回值是一个函数对象
			适用场景：常用于有切面需求的场景，如：插入日志、性能测试、事务处理、缓存、权限校验等。
			构成：需要一个装饰器函数(wrapper())和 @语法糖 和装饰器 和添加的功能
			使用：当需要装饰某一个原函数时，在原函数的函数声明前加上"@+装饰器名称"即可
			装饰器类型：
				a.有些装饰器是需要参数的
				b.基于类实现的装饰器(类装饰器)：装饰器中的装饰器函数其实是一个接口约束，这个装饰器函数(wrapper())必须接受一个callable对象作为参数然后返回一个callable对象
					(在python中callable对象一般都是函数，也有例外，如果某个对象的构造函数__init__()接收原函数，并且重载了__call__()方法，那么这个对象就是callable的)
				c.带参数的类装饰器：在类的构造函数中添加需要的参数，并重载__call__()函数，让这个内置函数返回一个函数(原函数)
				d.内置的装饰器：内置装饰器和普通装饰器原理一样，只不过返回的不是函数，而是类对象。
					@property：经过@property修饰的函数返回的不再是一个函数，而是一个property对象。
								它有三个装饰器：setter，getter，deleter，其中setter和deleter时property()的第二和第三个参数。
					@staticmethod:返回一个staticmethod类对象， 调用的是__init__()构造函数
					@classmethod:返回一个classmethod了对象，调用的时__init__()构造函数
				e.__call__()是一个特殊方法，它可以将一个类实例变成一个可调用对象。
				总结：带参数的装饰器，会比不带参数的装饰器中多一层函数。
			装饰器链：一个python函数可以被多个装饰器修饰，有多个装饰器时，执行顺序：从远到近依次执行。
			python装饰器库：functools，为了防止被装饰函数自身的信息丢失，可以使用functools。wraps()函数。即在修饰器函数中写入“@wraps(func)”。
			注意：
				最好不要在装饰器函数之外添加逻辑功能；
			
		迭代器(iterator):
			定义：迭代器是一个可以记住遍历位置的对象
			方法：迭代器有两个基本方法iter()创建迭代器和next()访问下一个元素
			迭代器可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到抛出StopIteration异常。
			可以将list,dict,str等Iterable通过iter()函数获取一个Iterator对象。
	
	
	